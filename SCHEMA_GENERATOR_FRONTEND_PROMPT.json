{
  "task": "Create a Schema Generator component/page that integrates with the Schema Generator API backend. This is a standalone tool that lets users paste their full HTML code, send it to the AI backend, and get back a production-ready JSON-LD schema markup. The tool must support real-time pipeline progress via SSE (Server-Sent Events), and provide two output options: copy plain schema JSON-LD or copy the original HTML with schema injected.",

  "project_context": {
    "description": "This is a React/Next.js frontend application. We need to add a new page/component called 'Schema Generator' that connects to our existing backend API. The backend is already deployed and working â€” we only need to build the frontend.",
    "backend_base_url": "https://video.celiyo.com",
    "api_prefix": "/api/schema-generator",
    "tech_stack_preference": "Use whatever framework the project already uses (React, Next.js, Vue, etc.). If starting fresh, use React with Vite.",
    "styling": "Use modern, dark-themed UI with glassmorphism, gradients, and micro-animations. Make it look premium and professional â€” similar to Vercel or Linear design aesthetics."
  },

  "api_endpoints": [
    {
      "name": "Generate Schema (SSE Stream)",
      "method": "POST",
      "url": "https://video.celiyo.com/api/schema-generator/generate-stream",
      "content_type": "application/json",
      "authentication": "None required",
      "description": "Sends HTML content to the AI backend, which processes it through a 7-step pipeline and returns a complete JSON-LD schema via Server-Sent Events (SSE). The response is NOT a regular JSON response â€” it's an SSE stream that sends multiple events over time as the pipeline progresses.",

      "request_body": {
        "htmlContent": {
          "type": "string",
          "required": true,
          "min_length": 50,
          "description": "The complete HTML source code of a web page. This is the raw HTML that the user pastes. Must be at least 50 characters. The backend stores this as-is (original) and creates a separate cleaned copy for processing."
        },
        "url": {
          "type": "string",
          "required": false,
          "description": "The URL of the web page (e.g., https://example.com/about). This helps the AI convert relative URLs to absolute URLs in the schema and improves accuracy. Optional but recommended."
        }
      },

      "request_example": {
        "htmlContent": "<!DOCTYPE html><html lang=\"en\"><head><title>My Page</title><meta name=\"description\" content=\"Page description\"></head><body><h1>Welcome</h1><p>Content here...</p></body></html>",
        "url": "https://example.com/my-page"
      },

      "response_type": "text/event-stream (SSE)",
      "response_format_explanation": "The response is a Server-Sent Events stream. Each event has two lines: 'event: <type>' and 'data: <json>'. Events are separated by blank lines. You MUST use the ReadableStream API (response.body.getReader()) to read this â€” NOT response.json().",

      "sse_events": [
        {
          "event_name": "step",
          "description": "Fired when a pipeline stage starts or completes. There are 7 stages total.",
          "data_schema": {
            "step": "string â€” one of: minify, chunk, detect, extract, schema, validate, inject",
            "status": "string â€” either 'active' (in progress) or 'done' (completed)",
            "message": "string â€” human-readable status message to display in the UI",
            "detection": "object (ONLY present when step=detect and status=done) â€” contains pageType, contentSummary, schemaTypes array, primaryKeywords array, aiSeoFocus"
          },
          "examples": [
            {"step": "minify", "status": "active", "message": "Extracting metadata & cleaning HTML..."},
            {"step": "minify", "status": "done", "message": "Cleaned: 45,230 â†’ 12,450 chars (72% reduced)"},
            {"step": "detect", "status": "done", "message": "Detected: Blog Post | Schemas: BlogPosting, WebPage, WebSite", "detection": {"pageType": "Blog Post", "contentSummary": "A guide about coffee brewing", "schemaTypes": ["BlogPosting", "WebPage", "WebSite", "BreadcrumbList"], "primaryKeywords": ["coffee", "brewing"], "aiSeoFocus": "Expert coffee guide"}},
            {"step": "inject", "status": "done", "message": "Schema injected into original HTML successfully"}
          ]
        },
        {
          "event_name": "progress",
          "description": "Fired during the extraction stage for each chunk being processed. Use this to show a progress bar or counter.",
          "data_schema": {
            "message": "string â€” e.g., 'Extracting data from chunk 2/3...'",
            "current": "number â€” current chunk number",
            "total": "number â€” total chunks"
          },
          "example": {"message": "Extracting data from chunk 2/3...", "current": 2, "total": 3}
        },
        {
          "event_name": "result",
          "description": "Fired ONCE when the pipeline completes successfully. Contains the final schema and the HTML with schema injected. THIS IS THE MAIN OUTPUT.",
          "data_schema": {
            "schema": "string â€” Complete JSON-LD schema wrapped in <script type='application/ld+json'>...</script> tags. This is the plain schema that users can copy and paste into their HTML <head> manually.",
            "htmlWithSchema": "string â€” The ORIGINAL HTML (exactly as the user pasted it) with the schema <script> tag injected before </head>. Users can copy this to replace their entire HTML file.",
            "detection": "object â€” same detection object as in the step event (pageType, schemaTypes, etc.)",
            "stats": "object â€” { originalSize: number, minifiedSize: number, chunks: number, schemaTypes: string[], pageType: string }"
          },
          "example_data": {
            "schema": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@graph\": [...]\n}\n</script>",
            "htmlWithSchema": "<!DOCTYPE html><html><head><title>...</title>\n<script type=\"application/ld+json\">...</script>\n</head><body>...</body></html>",
            "detection": {"pageType": "Blog Post", "schemaTypes": ["BlogPosting", "WebPage"]},
            "stats": {"originalSize": 45230, "minifiedSize": 12450, "chunks": 3, "schemaTypes": ["BlogPosting", "WebPage", "WebSite"], "pageType": "Blog Post"}
          }
        },
        {
          "event_name": "error",
          "description": "Fired if any error occurs during the pipeline. Display this as an error message to the user.",
          "data_schema": {
            "message": "string â€” error description"
          },
          "example": {"message": "Failed to detect page type. The content might be too short or unclear."}
        },
        {
          "event_name": "done",
          "description": "The final event. Signals the SSE stream is ending. Pipeline is complete.",
          "data_schema": {
            "message": "string â€” always 'Complete!'"
          }
        }
      ],

      "error_responses_before_sse": [
        {
          "status": 400,
          "body": {"error": "Please paste valid HTML content (at least 50 characters)."},
          "when": "htmlContent is missing or less than 50 characters"
        },
        {
          "status": 500,
          "body": {"error": "OPENAI_API_KEY (Groq key) is not configured on the server."},
          "when": "Server-side API key not set"
        }
      ],

      "complete_event_flow_in_order": [
        "step (minify â†’ active)",
        "step (minify â†’ done)",
        "step (chunk â†’ active)",
        "step (chunk â†’ done)",
        "step (detect â†’ active)",
        "step (detect â†’ done) â€” includes detection object with pageType, schemaTypes, keywords",
        "step (extract â†’ active)",
        "progress (chunk 1/N)",
        "progress (chunk 2/N)",
        "progress (chunk N/N)",
        "step (extract â†’ done)",
        "step (schema â†’ active)",
        "progress (repairing schema...) â€” OPTIONAL, only if schema needs repair",
        "step (schema â†’ done)",
        "step (validate â†’ active)",
        "step (validate â†’ done)",
        "step (inject â†’ active)",
        "step (inject â†’ done)",
        "result â€” FINAL OUTPUT with schema + htmlWithSchema + detection + stats",
        "done"
      ]
    }
  ],

  "frontend_requirements": {
    "page_layout": {
      "description": "Single page tool with a modern dark theme. The page should have these sections from top to bottom:",
      "sections": [
        {
          "name": "Header",
          "content": "Title: 'Digi Schema Generator', subtitle: 'Instant SEO structured data generation. Paste your page source and let our intelligent engine build a complete, search-optimized JSON-LD schema for you.', badge: 'AI-Powered Optimization'"
        },
        {
          "name": "Input Section",
          "content": "A large textarea for pasting HTML code, a URL input field, and Generate + Clear buttons",
          "details": {
            "textarea": {
              "placeholder": "Paste your full HTML page code here...\n\nThe AI will automatically:\nâ€¢ Detect page type (Blog, Product, About, etc.)\nâ€¢ Choose the best schema types\nâ€¢ Extract all links, images & data\nâ€¢ Generate copy-paste ready JSON-LD",
              "min_height": "200px",
              "should_accept": "Raw HTML code pasted by the user. Support standard paste (Ctrl+V). The textarea should handle very large HTML content (50,000+ characters) without lag. Use a monospace font for code display.",
              "important": "This is a CODE input, not a rich text editor. Users paste raw HTML source code. Do NOT convert or render the HTML â€” store it as a plain text string."
            },
            "url_input": {
              "placeholder": "https://yoursite.com/page-slug",
              "label": "Base URL (optional â€” helps make relative URLs absolute)"
            },
            "generate_button": {
              "text": "âœ¦ Generate Schema",
              "behavior": "Disabled while pipeline is running. Show loading state.",
              "style": "Prominent purple/violet gradient button"
            },
            "clear_button": {
              "text": "Clear",
              "behavior": "Clears textarea, URL input, resets pipeline, clears output"
            }
          }
        },
        {
          "name": "Pipeline Progress",
          "content": "Visual pipeline showing 7 steps: Clean â†’ Chunk â†’ Recognize â†’ Extract â†’ Schema â†’ Validate â†’ Inject",
          "details": {
            "display": "Horizontal row of 7 step indicators (pill-shaped or card-shaped)",
            "states": {
              "pending": "Gray/dim â€” step hasn't started yet",
              "active": "Pulsing/glowing animation â€” step is currently running",
              "done": "Green/success â€” step completed",
              "error": "Red â€” step failed"
            },
            "step_labels": ["1. Clean", "2. Chunk", "3. Recognize", "4. Extract", "5. Schema", "6. Validate", "7. Inject"],
            "step_mapping": {
              "minify": "Clean",
              "chunk": "Chunk",
              "detect": "Recognize",
              "extract": "Extract",
              "schema": "Schema",
              "validate": "Validate",
              "inject": "Inject"
            },
            "below_pipeline": "Show the current step's message text below the pipeline indicators"
          }
        },
        {
          "name": "AI Detection Results Card",
          "content": "Shows after the detect step completes. Displays what the AI detected about the page.",
          "details": {
            "show_when": "step=detect and status=done",
            "fields_to_display": [
              {"label": "Page Type", "value": "detection.pageType", "style": "Large bold text"},
              {"label": "Content Summary", "value": "detection.contentSummary", "style": "Normal text"},
              {"label": "Auto-Selected Schema Types", "value": "detection.schemaTypes", "style": "Array of colored badges/chips"},
              {"label": "Primary Keywords", "value": "detection.primaryKeywords", "style": "Array of colored badges/chips (different color from schema types)"}
            ]
          }
        },
        {
          "name": "Output Section",
          "content": "Shows after the result event. Has TWO tabs for different output formats, each with a copy button.",
          "details": {
            "show_when": "result event received",
            "tabs": [
              {
                "tab_name": "JSON-LD Schema Code",
                "icon": "{ } or code icon",
                "content": "Display result.schema in a code block with syntax highlighting. This is the <script type='application/ld+json'>...</script> content.",
                "copy_button": {
                  "text": "ðŸ“‹ Copy Schema",
                  "copies": "result.schema",
                  "feedback": "Show 'Copied!' tooltip for 2 seconds after clicking"
                },
                "helper_text": "Copy-paste this schema into your HTML <head> section"
              },
              {
                "tab_name": "HTML + Schema",
                "icon": "HTML icon",
                "content": "Display result.htmlWithSchema in a code block. This is the user's ORIGINAL HTML with the schema injected before </head>.",
                "copy_button": {
                  "text": "ðŸ“‹ Copy HTML",
                  "copies": "result.htmlWithSchema",
                  "feedback": "Show 'Copied!' tooltip for 2 seconds after clicking"
                },
                "helper_text": "Your original HTML with schema already injected â€” replace your entire file with this"
              }
            ],
            "code_display": {
              "font": "monospace (Fira Code, JetBrains Mono, or similar)",
              "background": "dark code editor style background",
              "max_height": "500px with vertical scroll",
              "word_wrap": "enabled",
              "line_numbers": "optional but nice to have"
            }
          }
        },
        {
          "name": "Stats Footer",
          "content": "Shows generation statistics after completion",
          "fields": [
            "Original: {stats.originalSize} chars",
            "Cleaned: {stats.minifiedSize} chars",
            "Chunks: {stats.chunks}",
            "Page: {stats.pageType}",
            "Schemas: {stats.schemaTypes.join(', ')}"
          ]
        }
      ]
    },

    "sse_parsing_implementation": {
      "description": "CRITICAL: The API returns Server-Sent Events, NOT regular JSON. You must parse the SSE stream correctly.",
      "implementation": "Use fetch() with response.body.getReader() and TextDecoder to read the stream. Parse each SSE event (lines starting with 'event:' and 'data:').",
      "code_reference": "async function generateSchema(htmlContent, url) {\n  const response = await fetch('https://video.celiyo.com/api/schema-generator/generate-stream', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ htmlContent, url })\n  });\n\n  if (!response.ok) {\n    const err = await response.json();\n    throw new Error(err.error);\n  }\n\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let buffer = '';\n  let currentEvent = '';\n\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n\n    buffer += decoder.decode(value, { stream: true });\n    const lines = buffer.split('\\n');\n    buffer = lines.pop();\n\n    for (const line of lines) {\n      if (line.startsWith('event: ')) {\n        currentEvent = line.slice(7).trim();\n      } else if (line.startsWith('data: ')) {\n        const data = JSON.parse(line.slice(6));\n        // Handle event based on currentEvent:\n        // 'step' â†’ update pipeline UI\n        // 'progress' â†’ update progress counter\n        // 'result' â†’ store schema + htmlWithSchema\n        // 'error' â†’ show error\n        // 'done' â†’ mark complete\n      }\n    }\n  }\n}",
      "common_mistakes_to_avoid": [
        "Do NOT use response.json() â€” this is SSE, not JSON",
        "Do NOT use EventSource â€” it only supports GET requests, this is POST",
        "Do NOT forget to keep a buffer for incomplete lines between chunks",
        "Do NOT parse lines that don't start with 'event:' or 'data:' â€” ignore blank lines"
      ]
    },

    "ui_interactions": {
      "generate_button_states": {
        "idle": "Enabled, shows 'âœ¦ Generate Schema'",
        "loading": "Disabled, shows spinner + 'Generating...'",
        "done": "Enabled again, shows 'âœ¦ Generate Schema'",
        "error": "Enabled again, shows 'âœ¦ Generate Schema'"
      },
      "status_indicator": "Show a status bar below the input section: 'Ready â€” paste HTML and click Generate' â†’ 'Processing...' â†’ 'âœ¨ Schema generated! Switch tabs to view.' â†’ 'Error: ...'",
      "textarea_behavior": {
        "paste_support": "Must support Ctrl+V / Cmd+V paste of large HTML content",
        "character_count": "Optionally show character count of pasted HTML",
        "no_rendering": "Do NOT render the HTML. Show it as raw text in a textarea or code editor."
      },
      "copy_feedback": "When user clicks Copy, briefly show 'Copied!' feedback (tooltip, toast, or button text change)",
      "responsive": "Must work on mobile and desktop. Stack sections vertically on mobile."
    },

    "design_guidelines": {
      "theme": "Dark theme with deep navy/slate background (#0a0a1a or similar)",
      "accent_color": "Purple/violet gradient (#7c3aed to #a855f7)",
      "cards": "Dark cards with subtle border (rgba(255,255,255,0.1)) and glassmorphism (backdrop-filter: blur)",
      "typography": "Use Inter, Outfit, or system font stack. Monospace for code areas.",
      "animations": {
        "pipeline_steps": "Pulse/glow animation on active step",
        "transitions": "Smooth 0.3s transitions on all state changes",
        "success": "Subtle green glow or check animation on completion"
      },
      "code_blocks": "Dark editor background (#1a1a2e), with scrollable overflow and syntax-like coloring",
      "badges": "Rounded pill badges for schema types (purple) and keywords (blue/teal)"
    }
  },

  "important_notes": [
    "The textarea accepts RAW HTML source code â€” not rendered HTML. Users copy-paste their page's source code into it.",
    "The API takes 10-60 seconds to complete because it makes MULTIPLE AI calls (detect â†’ extract per chunk â†’ generate â†’ validate â†’ repair). Show real-time progress to keep the user engaged.",
    "The result.schema is a complete <script type='application/ld+json'>...</script> string â€” NOT raw JSON. Display it as-is in the code block.",
    "The result.htmlWithSchema is the user's ORIGINAL HTML with the schema script tag injected before </head>. This preserves all their original formatting, styles, scripts, etc.",
    "CORS is enabled on the backend â€” no proxy needed from the frontend.",
    "No authentication is required for this endpoint.",
    "The SSE stream MUST be parsed using fetch + ReadableStream reader â€” NOT EventSource (which only supports GET).",
    "Handle the case where the API returns a non-200 status BEFORE the SSE stream starts (400 for bad input, 500 for server error). These return regular JSON error objects.",
    "The pipeline has 7 steps: minify â†’ chunk â†’ detect â†’ extract â†’ schema â†’ validate â†’ inject. Map these to your UI step indicators."
  ]
}
